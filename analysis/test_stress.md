СПИСОК ФАЙЛОВ

# Вход и цель
- [Факт] Файл `services/q_core_agent/state/tests/test_stress.py` — набор stress‑тестов для `AsyncStateStore` и связанных компонентов.
- [Факт] Итог: обзор тестовых сценариев, рисков и предложений.

# Сбор контекста
- [Факт] Использует `pytest`, `asyncio`, `psutil`, `random`, `ThreadPoolExecutor`, `ProcessPoolExecutor`.
- [Факт] Тестирует модули `store`, `types`, `conv`.
- [Гипотеза] Предназначен для оценки производительности и устойчивости перед продакшном.

# Локализация артефакта
- [Факт] Путь: `services/q_core_agent/state/tests/test_stress.py`.
- [Факт] Запускается через `pytest -m stress`.
- [Гипотеза] Требует платформу с достаточными ресурсами CPU и памяти.

# Фактический разбор
## Основные классы/фикстуры
- [Факт] `stress_store` — fixture создаёт инициализированный `AsyncStateStore`.
- [Факт] `PerformanceMonitor` — контекстный менеджер для измерения времени/памяти/операций.
## Тестовые группы
- [Факт] `TestHighVolumeOperations` проверяет массовые set/get и быструю смену состояний.
- [Факт] `TestConcurrencyStress` — конкурентные писатели, хаос операций, backpressure подписчиков.
- [Факт] `TestMemoryStress` — большие снапшоты и очистка подписчиков.
- [Факт] `TestLongRunningStability` — длительный микс операций.
- [Факт] `TestErrorHandlingStress` — инъекция ошибок и истощение ресурсов.
- [Факт] `TestPerformanceBenchmarks` — throughput и latency.
## Поведение и граничные случаи
- [Факт] Используются большие циклы, случайные данные, множество конкурентных задач.
- [Гипотеза] Возможны нестабильные результаты на слабом железе.

# Роль в системе и связи
- [Факт] Проверяет устойчивость StateStore под высокой нагрузкой.
- [Гипотеза] Выявляет деградацию производительности и проблемы очистки ресурсов.

# Несоответствия и риски
- [Гипотеза] Множество `print` может замедлять тесты (Med).
- [Гипотеза] Жёсткие assert по метрикам могут падать на загруженных CI (Med).
- [Гипотеза] Возможна утечка подписчиков при аварийном завершении (Low).

# Мини‑патчи (safe-fix)
- [Патч] Добавить параметризация по нагрузке для быстрого/полного режима.
- [Патч] Логировать результаты через `logging` вместо `print`.

# Рефактор‑скетч
```python
class PerformanceMonitor:
    def __enter__(self):
        self.start = time.time(); return self
    def __exit__(self, *args):
        self.duration = time.time() - self.start
```

# Примеры использования
```bash
# 1. Полный стресс-тест
python3 -m pytest services/q_core_agent/state/tests/test_stress.py -v -s
# 2. Запуск только тестов производительности
python3 -m pytest services/q_core_agent/state/tests/test_stress.py -k performance -v
# 3. Запуск группы memory
python3 -m pytest services/q_core_agent/state/tests/test_stress.py -k memory -v
# 4. Маркер stress с таймаутом
python3 -m pytest services/q_core_agent/state/tests/test_stress.py -m stress --timeout=120
# 5. Быстрый локальный прогон (укороченные циклы)
STRESS_TEST_DURATION=0.5 python3 -m pytest services/q_core_agent/state/tests/test_stress.py -k long_running -v
```

# Тест‑хуки/чек‑лист
- [Факт] Проверить что `get_metrics()` возвращает ожидаемые значения.
- [Факт] Убедиться в отсутствии утечек подписчиков после `unsubscribe`.
- [Факт] Валидировать, что `error_rate < 5%` в хаотичных тестах.
- [Факт] Для бенчмарков убедиться, что OPS/latency превышают заданные пороги.
- [Факт] При ресурсном истощении `health_check()` должен возвращать проблемы.

# Вывод
1. [Факт] Файл охватывает широкий спектр стресс‑сценариев.
2. [Факт] Используется общий `PerformanceMonitor` для метрик.
3. [Гипотеза] Жёсткие пороги могут быть слишком строгими для медленных CI.
4. [Факт] Есть тесты устойчивости, памяти и конкуренции.
5. [Патч] Ввести уровни нагрузки через переменные окружения.
6. [Гипотеза] Следует документировать ожидаемое аппаратное окружение.
7. [Патч] Перевести `print` на `logging` с уровнями.
8. [Гипотеза] Возможно вынести общие helper‑функции в отдельный модуль.
9. [Патч] Добавить очистку после `resource_exhaustion` теста.
10. [Гипотеза] Можно интегрировать результаты в отчёт `hot_test_statestore.sh`.

СПИСОК ФАЙЛОВ
